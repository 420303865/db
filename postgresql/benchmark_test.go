package postgresql

import (
	"database/sql"
	"fmt"
	"math/rand"
	"testing"

	"github.com/jmoiron/sqlx"
	"upper.io/db"
)

const (
	testRows = 10000
)

// BenchmarkSQLAppend benchmarks raw INSERT SQL queries without using prepared
// statements nor arguments.
func BenchmarkSQLAppend(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`TRUNCATE TABLE "artist"`); err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err = driver.Exec(`INSERT INTO "artist" ("name") VALUES('Hayao Miyazaki')`); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkSQLAppendWithArgs benchmarks raw SQL queries with arguments but
// without using prepared statements. The SQL query looks like the one that is
// generated by upper.io/db.
func BenchmarkSQLAppendWithArgs(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`DELETE FROM "artist"`); err != nil {
		b.Fatal(err)
	}

	args := []interface{}{
		"Hayao Miyazaki",
	}

	var rows *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if rows, err = driver.Query(`INSERT INTO "artist" ("name") VALUES($1) RETURNING "id"`, args...); err != nil {
			b.Fatal(err)
		}
		rows.Close()
	}
}

// BenchmarkSQLPrepareAppend benchmarks raw INSERT SQL queries using prepared
// statements but no arguments.
func BenchmarkSQLPrepareAppend(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`TRUNCATE TABLE "artist"`); err != nil {
		b.Fatal(err)
	}

	stmt, err := driver.Prepare(`INSERT INTO "artist" ("name") VALUES('Hayao Miyazaki')`)
	if err != nil {
		b.Fatal(err)
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err = stmt.Exec(); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkSQLAppendWithArgs benchmarks raw INSERT SQL queries with arguments
// using prepared statements. The SQL query looks like the one that is
// generated by upper.io/db.
func BenchmarkSQLPrepareAppendWithArgs(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`DELETE FROM "artist"`); err != nil {
		b.Fatal(err)
	}

	stmt, err := driver.Prepare(`INSERT INTO "artist" ("name") VALUES($1) RETURNING "id"`)

	if err != nil {
		b.Fatal(err)
	}

	args := []interface{}{
		"Hayao Miyazaki",
	}

	var rows *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if rows, err = stmt.Query(args...); err != nil {
			b.Fatal(err)
		}
		rows.Close()
	}
}

// BenchmarkSQLAppendWithVariableArgs benchmarks raw INSERT SQL queries with
// arguments using prepared statements. The SQL query looks like the one that
// is generated by upper.io/db.
func BenchmarkSQLPrepareAppendWithVariableArgs(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`DELETE FROM "artist"`); err != nil {
		b.Fatal(err)
	}

	stmt, err := driver.Prepare(`INSERT INTO "artist" ("name") VALUES($1) RETURNING "id"`)

	if err != nil {
		b.Fatal(err)
	}

	var rows *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		args := []interface{}{
			fmt.Sprintf("Hayao Miyazaki %d", rand.Int()),
		}
		if rows, err = stmt.Query(args...); err != nil {
			b.Fatal(err)
		}
		rows.Close()
	}
}

// BenchmarkSQLPrepareAppendTransactionWithArgs benchmarks raw INSERT queries
// within a transaction block with arguments and prepared statements. SQL
// queries look like those generated by upper.io/db.
func BenchmarkSQLPrepareAppendTransactionWithArgs(b *testing.B) {
	var err error
	var sess db.Database
	var tx *sql.Tx

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if tx, err = driver.Begin(); err != nil {
		b.Fatal(err)
	}

	if _, err = tx.Exec(`TRUNCATE TABLE "artist"`); err != nil {
		b.Fatal(err)
	}

	stmt, err := tx.Prepare(`INSERT INTO "artist" ("name") VALUES($1) RETURNING "id"`)
	if err != nil {
		b.Fatal(err)
	}

	args := []interface{}{
		"Hayo Miyazaki",
	}

	var rows *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if rows, err = stmt.Query(args...); err != nil {
			b.Fatal(err)
		}
		rows.Close()
	}

	if err = tx.Commit(); err != nil {
		b.Fatal(err)
	}
}

// BenchmarkUpperAppend benchmarks an insertion by upper.io/db.
func BenchmarkUpperAppend(b *testing.B) {

	sess, err := db.Open(Adapter, settings)
	if err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	artist, err := sess.Collection("artist")
	if err != nil {
		b.Fatal(err)
	}

	artist.Truncate()

	item := struct {
		Name string `db:"name"`
	}{"Hayao Miyazaki"}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err = artist.Append(item); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkUpperAppendVariableArgs benchmarks an insertion by upper.io/db
// with variable parameters.
func BenchmarkUpperAppendVariableArgs(b *testing.B) {

	sess, err := db.Open(Adapter, settings)
	if err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	artist, err := sess.Collection("artist")
	if err != nil {
		b.Fatal(err)
	}

	artist.Truncate()

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		item := struct {
			Name string `db:"name"`
		}{fmt.Sprintf("Hayao Miyazaki %d", rand.Int())}
		if _, err = artist.Append(item); err != nil {
			b.Fatal(err)
		}
	}
}

// BenchmarkUpperAppendTransaction benchmarks insertion queries by upper.io/db
// within a transaction operation.
func BenchmarkUpperAppendTransaction(b *testing.B) {
	var sess db.Database
	var err error

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	var tx db.Tx
	if tx, err = sess.Transaction(); err != nil {
		b.Fatal(err)
	}

	var artist db.Collection
	if artist, err = tx.Collection("artist"); err != nil {
		b.Fatal(err)
	}

	if err = artist.Truncate(); err != nil {
		b.Fatal(err)
	}

	item := struct {
		Name string `db:"name"`
	}{"Hayao Miyazaki"}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err = artist.Append(item); err != nil {
			b.Fatal(err)
		}
	}

	if err = tx.Commit(); err != nil {
		b.Fatal(err)
	}
}

// BenchmarkUpperAppendTransactionWithMap benchmarks insertion queries by
// upper.io/db within a transaction operation using a map instead of a struct.
func BenchmarkUpperAppendTransactionWithMap(b *testing.B) {
	var sess db.Database
	var err error

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	var tx db.Tx
	if tx, err = sess.Transaction(); err != nil {
		b.Fatal(err)
	}

	var artist db.Collection
	if artist, err = tx.Collection("artist"); err != nil {
		b.Fatal(err)
	}

	if err = artist.Truncate(); err != nil {
		b.Fatal(err)
	}

	item := map[string]string{
		"name": "Hayao Miyazaki",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if _, err = artist.Append(item); err != nil {
			b.Fatal(err)
		}
	}

	if err = tx.Commit(); err != nil {
		b.Fatal(err)
	}
}

// BenchmarkSQLSelect benchmarks SQL select queries.
func BenchmarkSQLSelect(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`TRUNCATE TABLE "artist"`); err != nil {
		b.Fatal(err)
	}

	for i := 0; i < testRows; i++ {
		if _, err = driver.Exec(fmt.Sprintf(`INSERT INTO "artist" ("name") VALUES('Artist %d')`, i)); err != nil {
			b.Fatal(err)
		}
	}
	var res *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if res, err = driver.Query(`SELECT * FROM "artist" WHERE "name" = $1`, fmt.Sprintf("Artist %d", i%testRows)); err != nil {
			b.Fatal(err)
		}
		res.Close()
	}
}

// BenchmarkSQLPreparedSelect benchmarks SQL select queries using prepared
// statements.
func BenchmarkSQLPreparedSelect(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	driver := sess.Driver().(*sqlx.DB)

	if _, err = driver.Exec(`TRUNCATE TABLE "artist"`); err != nil {
		b.Fatal(err)
	}

	for i := 0; i < testRows; i++ {
		if _, err = driver.Exec(fmt.Sprintf(`INSERT INTO "artist" ("name") VALUES('Artist %d')`, i)); err != nil {
			b.Fatal(err)
		}
	}

	stmt, err := driver.Prepare(`SELECT * FROM "artist" WHERE "name" = $1`)
	if err != nil {
		b.Fatal(err)
	}

	var res *sql.Rows

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		if res, err = stmt.Query(fmt.Sprintf("Artist %d", i%testRows)); err != nil {
			b.Fatal(err)
		}
		res.Close()
	}
}

// BenchmarkUpperFind benchmarks upper.io/db's One method.
func BenchmarkUpperFind(b *testing.B) {
	var err error
	var sess db.Database

	if sess, err = db.Open(Adapter, settings); err != nil {
		b.Fatal(err)
	}

	defer sess.Close()

	artist, err := sess.Collection("artist")
	if err != nil {
		b.Fatal(err)
	}

	artist.Truncate()

	type artistType struct {
		Name string `db:"name"`
	}

	var item artistType

	for i := 0; i < testRows; i++ {
		item = artistType{
			Name: fmt.Sprintf("Artist %d", i),
		}
		if _, err = artist.Append(item); err != nil {
			b.Fatal(err)
		}
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		res := artist.Find(db.Cond{"name": fmt.Sprintf("Artist %d", i%testRows)})
		if err = res.One(&item); err != nil {
			b.Fatal(err)
		}
	}
}
